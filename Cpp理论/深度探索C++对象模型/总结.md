# **第一章 关于对象**

- 每一个非内联成员函数只会诞生一个函数实例，而内联函数则会在每一个使用者身上产生一个函数实例
- 简单对象模型：对象里存放的是指向数据和函数的指针
- 表格驱动对象模型：对象本身存放两个指针，一个指向存放数据成员的表（内含实际数据），另一个指向存放成员函数的表（内含函数地址）
- C++对象模型：对象中存放非静态数据成员，静态数据成员在类对象之外，成员函数统一放在类对象外，虚函数则放置在虚函数表里（含有指向虚函数的指针）
- 类中同处于一个访问权限的数据，保证以其声明的顺序出现在内存布局中；而处于多个访问权限的各个数据，其排列顺序则不一定
- 多态操作必须通过经由一个指针或引用来存取
- 类对象的大小：非静态数据成员+字节对齐+虚表指针
- 指针的大小是固定的（取决于机器位数），其指针类型只是教导编译器如何解释某个特定地址中的内存容量及大小
- 指针转换本质上不改变指针所含的真正地址，而是影响编译器对其的解释方式

---

# **第二章 构造函数语义学**

- 默认构造函数的生成：编译器认为有必要的时候，且只满足编译器的需要
- 非平凡默认构造函数的生成
  1. 类本身没有构造函数，但是内含一个类对象，该对象含有默认构造函数
  2. 在1的条件下，如果已有构造函数，则会对其扩张（先调用必要的类中对象的默认构造函数再执行用户代码）
  3. 没有构造函数的类是派生自一个带有默认构造函数的基类（该生成的构造函数会调用基类的默认构造函数）
  4. 在3的条件下，类已有构造函数则会对其扩张，调用所有必要的默认构造函数再执行用户代码
  5. 类声明或者继承一个虚函数
  6. 类派生自一个继承串链，其中有虚基类
- 编译期间的扩张行为：虚函数表（类）和虚表指针（类对象）被合成
- 虚表指针的初值是在构造函数中由编译器自行完成设定的
- 虚基类：在派生类对象的每一个虚基类中安插一个指针
- 默认构造函数：非平凡满足编译器的需要；平凡实际上不会被合成出来；不会对非静态成员进行初始化
- 默认拷贝构造函数：内部以默认成员初始化递归施行（将数据成员从一个对象拷贝到另一个对象中，针对类对象则是递归该步骤而不是直接拷贝）
- 不展现位逐次拷贝的情况
  - 类内含一个成员对象且该对象有拷贝构造函数（对象的拷贝构造函数被安插进去）
  - 类继承自一个基类，该基类有拷贝构造函数（基类的拷贝构造函数被安插进去）
  - 类声明一个或多个虚函数（拷贝构造函数会显式设定虚表指针的值而不是直接拷贝）
  - 类派生自继承串链，其中有一个或多个虚基类
- 返回值的初始化（ROV）：函数加上额外参数（类对象的一个引用），将返回对象进行拷贝；函数实际上没有返回值
- 注意类对象虚表指针的初始化问题（编译器扩张的代码总是位于用户代码前）
- 构造函数的初始值设定在函数体内部，则会产生一个临时对象来进行位逐次拷贝
- 成员初始化列表的初始化顺序由成员声明顺序决定（编译器会将其安插到函数体用户代码之前执行）

---

# **第三章 语义学**

- 空类的大小为1以获得内存中的地址
- 虚基类中，派生类对象会存放指向虚基类表的指针（表中可能存放虚基类的指针或者其偏移位置）
- 非静态数据成员在类对象中的排列顺序和其被声明的顺序一样，任何中间的静态成员变量都不会影响
- 对静态数据成员取地址，将会得到一个指向其数据类型的指针而不是指向类成员的指针
- 将虚表指针放置在类对象的开头，避免编译期计算偏移量
- 基类和派生类的对象都是从相同的地址开始
- 取非静态数据成员的地址将会得到其在类中偏移量（没有实例化），如果对绑定对象（实例化）的非静态数据成员取地址将得到其在内存中的真正地址（使用printf函数而不是cout运算符）

---

# **语意学**

- 对静态成员函数取地址得到的将是其在内存中的位置；地址类型为非成员函数指针类型而不是指向类成员函数的指针

































































































    