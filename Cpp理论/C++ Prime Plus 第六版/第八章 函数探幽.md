# **内联函数**

- 原地展开

- 使用：在声明前加上关键字 `inline` 或定义前加上关键字 `inline` （此时声明和定义一起）

- 通常做法：省略原型（声明），将定义放在本提供原型的地方

- 内联函数不能递归，是否内联取决于编译器

---

# **引用变量**

- 主要用于形参

- 格式： `typeName & aliasName = valueName;`

- 两变量的值和地址都相同，操作对两者都有影响

- 必须在声明引用时进行初始化，实质为用 `const` 修饰的指针（指针指向不可变）

- 按引用传参尽可能使用 `const`，效果等同于按值传递但不创建临时内存

    ![引用传参.png](http://120.77.180.209/2022/03/07/5e4a4d9250677.png)

- 右值引用

  - 用法：`typeName && aliasName = value;`
  - 左右值的区别在于能不能取地址

- 用于结构体

  - 返回引用：不复制一份到临时位置而是直接拷贝过去
  - 返回引用时避免返回函数终止时不存在的内存单元引用
  - `const` 用于引用返回类型，不可修改的左值

- 其他

  - 基类引用可以指向派生类对象
  - 何时使用引用参数

    ![何时使用引用.png](http://120.77.180.209/2022/03/07/db16431ca0d46.png)

---

# **默认参数与函数重载**

- 默认参数

  - 使用：在函数原型里设置默认值（定义处不要重复设置）
  - 默认值必须从右向左添加

- 函数重载（多态）

  - 概念：函数名相同，返回类型可以不同，但参数的数目、类型和顺序（特征标）不完全一致
  - 注意：类型引用和类型本身是一致的，不能重载。同时也不区分 `const` 和非 `const`

---

# **函数模板**

- 形式：`template <typename AnyType> 函数声明/定义;`， `AnyType` 是泛型

- 常见使用：模板声明和定义放在同个头文件当中

- 模板重载

  - 函数特征标必须不完全相同，模板参数并非都要和模板完全一致
  - 函数：非模板函数 > 显式具体化函数 > 模板函数 （优先级）
  - 显式实例化：有别于显式具体化（声明），实例化是命令编译器生成特定类型的实例
  - 完全匹配和最佳匹配  

    ![匹配.png](http://120.77.180.209/2022/03/07/3fdce60daf433.png)

- 关键字 `decltype`

  - 格式：`decltype(expression) var;` 将变量 `var` 的类型指定为表达式的类型
  - 如果表达式是函数调用，则类型为该函数的返回类型
  - 后置返回类型：`auto 函数名(形参) -> decltype(expression);`