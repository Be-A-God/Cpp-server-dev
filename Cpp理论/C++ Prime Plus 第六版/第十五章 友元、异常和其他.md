# **友元**

- 友元类

  - 所有方法都可以访问原始类的私有成员和保护成员
  - 格式：`friend class className;` ，声明位置不影响

- 友元成员函数

  - 将另一个类特定的函数声明为友元
  - 注意声明顺序，使用前向声明

---

# **嵌套类**

- 概念：在另一个类中声明的类

- 不同于包含将类对象作为成员（组合），嵌套类不创建类成员，而是一种类型的定义

- 访问权限

  - 在另一个类的私有部份声明，则只有后者知道
  - 在另一个类的保护部分声明，对于后者和其派生类都可见
  - 在另一个类的公有部分声明，后者及其派生类和外部都可以使用，通过多层作用域解析符访问

- 模板中的嵌套：可以使用模板类的通用类型

---

# **异常**

- 调用 `abort()`

  - 位于头文件 `#include <cstdlib>` 
  - 是否刷新文件缓冲区取决于实现
  - `exit()` 可以刷新文件缓冲区但不显示消息
  - 直接终止程序

- 异常机制

  - `throw` 语句实际是跳转，类似返回语句，终止函数的执行
  - `catch` 关键字捕获异常， `try` 表示特定的异常可能被激活的代码块
  - 没有 `try-catch` 模块则默认调用 `abort()` 函数
  - 可以使用多个 `catch` 模块

- 异常规范

  - C++11 使用 `noexcept` 关键字保证函数不会引发异常（在声明中）
  - 运算符 `noexcept(exp)` ，当表达式为假表示可能引发异常，为真表示不引发异常

- 栈解退

  - 概念

     > 函数由于出现异常（而不是由于返回）而终止，则程序也将释放栈中的内存，但不会在释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于 `try` 块中的返回地址。随后控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句

  - 其他异常特性

    - 引发异常时编译器总是创建一个临时拷贝，即使指定的是引用
    - 异常捕获顺序和派生顺序相反，基类可以捕获派生类
    - 使用省略号 `...` 捕获所有异常

---

# **RTTI运行阶段类型识别**

- 工作原理

  - `dynamic_cast` ：使用一个只想基类的指针来生成一个指向派生类的指针；否则返回空指针
  - `typeid` ：返回一个 `type_info` 类对象的引用
  - `type_info` ：该类包含有关特定类型的信息（如 `name()` 成员返回类的名称）

- `dynamic_cast`

  - 只适用于包含虚函数的类，只有包含虚函数的类才能将派生类对象的地址赋给基类指针
  - 确定是否可以安全地将对象的地址赋给特定类型的指针
  - 默认下关闭 `RTTI` 特性

- `typeid` 运算符和 `type_info` 类
  - `typeid` ：接受两种参数：类名或结果为对象的表达式；返回一个 `type_info` 对象的引用
  - 对空指针进行 `typeid` 运算符将引发 `bad_typeid` 异常

- 原则：优先考虑虚函数和 `dynamic_cast` 运算符

---

# **类型转换运算符**

- 四个类型转换运算符：`dynamic_cast` `const_cast` `static_cast` `reinterpret_cast`

- `dynamic_cast` ：允许向上转换，不允许其他转换

- `const_cast` ：删除 `const` 属性，不能改变其类型

- `static_cast` ：仅当类型转换本身已被隐式转换时合法

- `reinterpret_cast` ： 允许将任何指针转换为任何其他指针类型；还允许将任何整数类型转换为任何指针类型，反之亦然（不安全）