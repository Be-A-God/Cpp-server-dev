# **琐碎**

    语法： class className : derivesType baseClass

    派生方式：公有继承 public ; 私有继承 private ; 保护继承 protect

    protect : 类外等同于私有部分，派生类等同于公有部分

---

# **继承**

- 需要自己的构造函数

  - 创建基类对象（形参处）
  - 通过成员初始化列表将基类信息传递给基类构造函数
  - 创建派生类对象时，先调用基类构造函数再调用派生类构造函数
  - 基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增数据成员
  - 形参之后使用 `:基类构造函数` 调用基类构造函数初始化

- 不能直接访问基类的私有成员变量，通过基类方法进行访问

- 派生类和基类声明可以放在同一份头文件中，定义也一同放一起（声明与定义分开）

- 关系

  - 派生类可以使用基类的公有方法
  - 基类指针（引用）可以在不进行显式类型转换的情况下指向派生类对象
  - 基类指针只能调用基类方法，属于派生类的部分无法调用（虚函数除外）
  - 不可以将基类对象和地址赋给派生类引用或指针

- 公有继承是 `is-a` 关系：对基类对象执行的操作，也可以对派生类对象执行

- 多态公有继承

  - 概念：同一个方法在派生类和基类中行为不同（重写）

  - 虚函数：解决基类、派生类同名同特征标方法调用时的选择问题

    - 声明前加上关键字 `virtual` ，定义中不需要写明关键字 `virtual`
    - 使用引用（指针）调用对象方法时，默认根据引用（指针）类型选择方法（非虚函数时）
    - 虚函数能够在运行时根据引用（指针）指向对象的真正类型选择调用的成员方法
    - 虚折构函数：确保释放派生类对象时，能够按照正确的顺序调用折构函数

  - 虚折构函数

    - 无虚折构函数时只调用对应引用（指针）类型的折构函数
    - 虚折构函数则根据引用（指针）指向对象的真正类型按正确顺序调用折构函数
    - 基类折构函数声明前加上关键字 `virtual`
    - 虚折构函数声明在基类中，派生类同样需要声明，包含关键字 `virtual`

- 继承与动态分配

  - 派生类使用 `new` 时必须为派生类定义显式折构函数、复制函数和赋值运算符（深拷贝）

---

# **静态联编和动态联编**

- 函数名联编：编译器将源代码中的函数调用解释为执行特定的函数代码

- 静态联编：编译器在编译过程中完成这种联编操作

- 动态联编：使用虚函数时运行时才能确定函数的调用

- 指针和引用类型的兼容性

  - 向上强制转换：将派生类引用（指针）转换为基类引用（指针）【动态联编】
  - 向下强制转换：将基类引用（指针）转换为派生类引用（指针）【不允许】

- 虚成员函数和动态联编

  - 虚成员函数就是对类的成员方法进行重写 `override`

  - 工作原理：给每个对象添加**虚指针**，指向**虚函数表**

  - 虚函数表：函数地址数组，存储了为类对象进行声明的虚函数的地址

  - 成本

    - 对象增大、增加了存储地址的空间
    - 每个类都创建一个虚函数表
    - 每个函数调用都要到表中查找地址

  - 注意事项

    - 构造函数不能是虚函数

    - 折构函数应当是虚函数，除非类不用作基类，即使折构函数不执行操作也指出其为虚函数

    - 友元不能是虚函数，友元不是类成员，只有成员才能是虚函数

    - 重新定义将隐藏方法

      - 派生类中重新定义函数，将隐藏同名的基类方法
      - 使用 `override` 限定符确保正确重写虚函数
      - 重新定义基类的方法，应确保与原来的原型完全相同
      - 返回类型协变：返回类型可以修改为指向派生类的引用（指针）
      - 基类声明被重载，则应在派生类中重写所有的基类（重载）版本

---

# **抽象基类**

    纯虚函数提供未实现的函数（抽象）

    形式：纯虚函数声明的结尾处为 `= 0`

    特点：含有纯虚函数时不能创建该类的对象，只能做基类

    纯虚函数允许有定义

    抽象基类：在原型中含有纯虚函数的基类，纯虚函数在基类中可以不定义