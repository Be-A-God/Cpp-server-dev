# **OPP**

    派生类形式：类名后一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有访问说明符

    派生类必须对所有重新定义的虚函数进行声明

    派生类使用关键字 `override` 显式地注明虚函数改写

    使用基类地引用（指针）调用虚函数将发生动态绑定（运行时绑定）

---

# **定义基类和派生类**

- 定义基类

  - 基类通常都应该定义一个虚折构函数，即使该函数不执行任何实际操作
  - 关键字 `virtual` 只能出现地类内部声明语句而不能用于类外部的函数定义
  - 基类中的虚函数在派生类中隐式地声明为虚函数
  - 派生类能够访问基类公有成员，而不能访问私有成员
  - 适当使用 `protect` 访问说明符

- 定义派生类

  - C++11使用关键字 `override` 显式重写虚函数（编译器会进行检查）
  - 基类引用（指针）能够调用派生类引用（指针）
  - 派生类可以使用基类的构造函数初始化其基类部分
  - 首先初始化基类的部分，再按照声明顺序依次初始化派生类的成员
  - 派生类的作用域嵌套在基类的作用域之内
  - 基类的静态成员在整个继承体系中只存在唯一定义和唯一实例
  - 基类的静态成员可以通过基类或派生类进行访问

- 防止继承的发生：类名之后紧跟关键字 `override`

- 类型转换与继承

  - 智能指针类也支持派生类向基类的类类型转换
  - 用派生类对象为一个基类对象初始化或赋值时，派生类部分将被忽略

---

# **虚函数**

    派生类虚函数的函数名、形参类型和返回类型必须和基类虚函数完全一致（返回类型协变除外）

    `final` 函数不可以重写覆盖

    虚函数可以拥有默认实参

    基类和派生类中虚函数定义的默认实参最好一致

    强制执行虚函数某个特定版本，使用作用域解析符实现

---

# **抽象基类**

    纯虚函数：无需实现定义，声明处使用 `=0`

    纯虚函数也可以提供定义，但是只能在类的外部定义

    含有纯虚函数的类是抽象类

    抽象类的对象不能直接创建

---

# **访问控制与继承**
- 受保护成员 `protect`

    ![第十五章 面向对象程序设计OOP-2022-03-14-07-50-23](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1OOP-2022-03-14-07-50-23.png)

- 派生类的成员和友元访问派生类对象中的基类部分的受保护成员

- 友元关系不会被继承，基类的友元在访问派生类成员时不具有特殊性

- 使用 `using` 声明改变派生类继承的某个名字的访问级别

- `using` 声明语句中名字的访问权限由该 `using` 声明语句之前的访问说明符决定

- 派生类只能为那些它可以访问的名字提供 `using` 声明

- 使用 `class` 关键字定义的派生类是私有继承， `struct` 关键字定义的则是公有继承

---

# **继承中的类作用域**

    派生类的作用域位于基类的作用域之内

    派生类重用定义基类中的名字，此时将隐藏基类的名字

    可以通过作用域解析符使用隐藏成员

    函数同名但是不是虚函数重写，则将隐藏基类中同名函数

    使用 `using` 语句可以将基类的所有重载版本的函数实例添加到派生类中

---

# **构造函数与拷贝控制**

- 对象的销毁与其创建的顺序相反
- `using` 声明语句作用于构造函数时，编译器将为其生成对应的派生类构造函数
- `using` 声明不能指定 `explicit` 或 `constexpr`
- 使用 `using` ，基类构造函数的默认实参不会被继承，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参（穷举）
- 使用 `using` ，派生类存在与基类构造函数相同参数列表的构造函数，则该构造函数将不会被继承
- 默认、拷贝和移动构造函数不会被继承

---

# **容器与继承**

    派生类对象被赋值给基类对象时，派生类部分被切除，因此容器与存在继承关系的类型无法兼容

    使用指向基类的指针（引用）时，更适合在容器中存放具有继承关系的对象
