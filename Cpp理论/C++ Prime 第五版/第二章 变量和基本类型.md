# **琐碎**

- C++ 算术类型

    ![算术类型.png](http://120.77.180.209/2022/03/09/e40c5497c020a.png)

- 数值范围：无符号类型溢出，结果为初始值对无符号类型表示数值总数取模后的余数

- 指定字面值类型

    ![字面值类型.png](http://120.77.180.209/2022/03/09/b767d469a2962.png)

- 列表初始化禁止窄缩

- 作用域解析符 `::` 可以覆盖默认作用域规则

- 引用即别名：定义时必须初始化，引用不是对象，自身不能被引用

- 引用绑定后不可以更改

- 不能定义指向引用的指针：引用不是对象，没有实际地址

- 指针的可能状态

  - 指向一个对象
  - 指向相邻对象所占空间的下一个位置
  - 空指针 `nullptr`
  - 无效指针，上述情况之外的值

- `void *` ：可以存放任意对象的地址

- 对指针的引用，采用从右到左的方式阅读更好理解

- `const` 限定符

  - 顶层 `const` ：其对象的值不可变
  - 底层 `const` ：对象地址不可变
  - 默认 `const` 变量是内部链接性，可以用 `extern` 消除
  - 常量引用相当于**指向常量的常量指针**

- 常量表达式 `constexpr`

  - 是一种类型声明，可以由编译器验证是否为常量表达式
  - 常量表达式在编译时确定其值

- 类型别名

  - `typedef` ：为类型起别名

    - 针对 `const` 的情况不能进行简单替换， `const` 是对给定类型的修饰

    ![别名.png](http://120.77.180.209/2022/03/09/d513f7a54684f.png)

  - 新方法： `using aliasName = initName;`

  - `auto` 类型说明符

    - 编译器根据初始值推断变量类型，定义时必须初始化
    - 忽略顶层 `const` ，保留底层 `const` 
    - 顶层 `const` 应该显式地指出

  - `decltype` 类型指示符

    - 从表达式的类型推断出变量类型
    - 变量使用括号包含时，则一定是引用类型