# **定义模板**

- 函数模板

  - `template` 加模板参数列表，模板参数列表不可以为空
  - 类型参数前必须使用 `class` 或 `typename`
  - 通过特定的类型名指定非类型模板参数
  - 函数模板可以声明为 `inline` 或 `constexpr` ，说明符放在模板参数列表之后，返回类型之前
  - 模板函数和类模板成员的定义通常放在头文件中

- 类模板

  - 定义类似函数模板
  - 定义在类模板内的成员函数隐式声明为内联函数
  - 成员函数没有被使用则不会实例化
  - 类模板外定义成员时，直到遇到类名才表示进入类的作用域
  - 类模板包含一个非模板友元，则友元被授权访问所有模板实例
  - 如果友元自身是模板，类授权给所有友元模板实例，也可以只授权特定实例（特例化）
  - 可以将模板类型参数声明为友元
  - 使用 `using` 和 `typedef` 为类模板定义一个类型别名
  - 类模板每个实例都有一个独立的 `static` 对象

- 模板参数

  - 参数名不能重用
  - 与函数参数相同，声明中的模板参数的名字不必与定义相同
  - 使用 `typename` 显式告诉编译器该类型成员是一个类型
  - 可以为函数模板和类模板提供默认模板实参
  - 使用所有默认实参时，模板参数列表用空尖括号表示 `<>`

- 成员模板：类外定义时同时知名类模板参数列表和成员模板参数列表

- 控制实例化

  - 显式实例化：使用 `extern` 模板声明，不会在文本中生成实例化代码（存在于程序其他位置）

---

# **模板实参推断**

- 顶层 `const` 在形参中和实参中被忽略
- 如果函数参数类型不是模板参数，则对实参进行正常的类型转换
- 可以显式指定模板参数类型（部分）
- 引用折叠、右值引用、函数参数转发
- 转发：将一个或多个实参连同类型不变地转发给其他函数
- 引用参数可以保持 `const` 属性
- 使用 `std::forward` 进行转发

---

# **重载与模板**

    函数模板可以被另一个模板或一个普通非模板函数重载

    非模板匹配优先于模板

---

# **可变参数模板**

    可变数目的参数成为参数包：模板参数包和函数参数包

    模板参数列表中，class... 或 typename... 指出可变参数

    可变参数函数通常是递归的（用于解包）

---

# **模板特例化**

    模板实例化：空尖括号以及具体的实参

    模板及其特例化版本应该声明在同一个头文件中

    向命名空间添加成员之前必须打开命名空间

    类模板允许部分特例化（函数模板不允许）
