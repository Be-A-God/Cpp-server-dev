# **异常处理**

- 抛出异常

  - 使用 `throw` 抛出异常

  - 执行 `throw` 语句后，后面的语句不再执行

  - 栈展开：沿着嵌套函数的调用链不断查找，直到找到与异常匹配的 `catch` 子句或者调用 `terminate` 终止程序

    - 退出块时对象被自动销毁
    - 折构函数需要执行某个可能抛出异常的操作，则该操作应该放置在 `try` 语句块中，并在折构函数内部得到处理

  - 异常对象：抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在

- 捕获异常

  - 使用 `catch` 子句捕获异常

  - 形同包含形参的函数

  - 形参类型必须是完全类型（可以是左值引用但不能是右值引用）

  - 如果与继承体系有关，最好将其参数定义成引用类型

  - `catch` 子句存在继承关系，则基类放在后面，派生类放在前面（基类能够捕获派生类异常）

  - 空的 `throw` 语句只能出现在 `catch` 子句或 `catch` 子句直接间接调用的函数之内

  - 使用省略号 `...` 捕获所有异常，通常放在最后面

  - 类型匹配

    ![第十八章 用于大型程序的工具-2022-03-14-20-39-57](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%20%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7-2022-03-14-20-39-57.png)

- 函数 `try` 语句块与构造函数

  - 处理构造函数抛出的异常必须将构造函数写成函数 `try` 语句块的形式
  - ~~关键字 `try` 出现在初始化列表的冒号之后以及构造函数体的花括号之前~~
  - 函数 `try` 语句块只能处理构造函数开始执行后发生的异常

- `noexcept` 异常声明

  - 指定某个函数不会抛出异常，跟在函数参数列表之后，出现在所有声明语句和定义语句中
  - 位于 `const` 及引用限定符 `&` `&&` 之后，`final` `override` 或纯虚函数的 `= 0` 之前
  - 可以在函数指针的声明和定义中指定，在 `typedef` 或类型别名中则不能出现
  - 说明位置应该在函数的尾置返回类型之前
  - 声明该关键字的函数一旦抛出异常，则调用 `terminate` 终止程序
  - `noexcept` 接受一个可选实参，`false` 表示函数可能抛出异常
  - 函数指针及该指针所指的函数必须具有一致的异常说明
  - 虚函数承诺不会抛出异常，则派生类对应的虚函数也必须做出同样承诺

- 异常类层次

    ![第十八章 用于大型程序的工具-2022-03-14-20-49-20](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0%20%E7%94%A8%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B7%A5%E5%85%B7-2022-03-14-20-49-20.png)

---

# **命名空间**

- 定义：`namespace space {}`
- 能出现在全局作用域中的声明就能置于命名空间内
- 与类一样，命名空间结束后无需分号
- 命名空间可以是不连续的，可以在多处定义（补充）
- 内联命名空间，关键字 `inline` ，出现在命名空间第一次定义处
- 匿名命名空间：变量具有静态生命周期；不能跨越多个文件；空间内变量使用不需要 `::`
- 一个命名空间可以有好几个同义词或别名
- 使用 `using` 声明或 `using` 指示引入命名空间

---

# **多重继承与虚继承**

- 共享基类子对象称为虚继承
- 虚继承中，派生类都只包含唯一一个共享的虚基类子对象
- 使用关键字 `virtual` 指定虚基类
- 虚基类构造顺序：虚基类子部分 -> 直接基类（按照派生列表中出现的次序）
- 虚基类总是先于非虚基类构造，与继承体系中的次序和位置无关
