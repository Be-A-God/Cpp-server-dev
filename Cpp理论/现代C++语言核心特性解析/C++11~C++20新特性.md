# **新基础类型（C++11～C++20）**

- `C++11` 新增整数类型 `long long` 
- `C++11` 新增新字符类型 `char16_t` 和 `char32_t`
- `C++17` 前缀 `u8` 支持字符（ `C++11` 只支持字符串字面量）
- `C++11` 新字符串支持连接
- `C++11` 引入编码字符转换的库函数
- `C++20` 引入 `char8_t` 代替 UTF-8 的字符类型和相应的库函数

---

# **内联和嵌套命名空间（C++11～C++20）**

- `C++11` 引入内联名字空间，可以无需指定子空间名称

- `C++17` 简化嵌套命名空间的语法

- `C++20` 简化内联命名空间语法（ `inline` 出现在除第一个命名空间外）

  ![20220316213333](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220316213333.png)
  ![20220316213344](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220316213344.png)

---

# **`auto`占位符（C++11～C++17）**

- `C++11` 自动推导变量的类型、尾置返回类型、静态成员变量必须使用 `const` 限定符、不可用于非静态成员变量

- `C++17` 取消对静态成员变量必须使用 `const` 限定符的限制

- `C++14` ， `auto` 可以为 `lambda` 表达式声明形参还有 `lambda` 表达式返回类型的自动推导

- `C++20` 可以在函数形参列表中使用 `auto` 声明形参

- 推导规则

  - 没有使用引用或指针时，忽略 `cv` 限定符

  - 目标对象时引用时，推导时忽略引用

  - 推导时会涉及引用折叠

  - `C++17` ： `auto` 与列表初始化相结合

    - 直接使用列表初始化时，列表内必须为单元素
    - 等号加列表初始化，内部元素必须类型相同，推导为 `std::initializer_list<T>`

  - `C++14` 支持 `auto` 用于函数返回类型的推导（无需尾置返回）；只能返回值类型

  - `C++17` 可以作为非类型模板形参的占位符（推导出的类型必须可用作模板形参）

---

# **`decltype` 说明符（C++11～C++17）**

- `C++11` 引入 `decltype` 说明符：获取对象或表达式的类型；用在非静态成员变量

- 推导规则

  - e 是未加括号的标识符表达式或未加括号的类成员访问，则推断为类型 T
  - e 是函数调用或者仿函数调用则推断为函数返回值的类型
  - e 是一个类型 T 的左值，则推断为 T&
  - e 是一个类型 T 的将亡值，则推断为 T&&
  - 加括号的标识符表达式一律推断为引用
  - 除以上则为 T

- `cv` 限定符的推导：通常会同步变量的 `cv` 限定符；若是未加括号的成员变量时，父表达式的 `cv` 限定符会被忽略

- `C++14` 引入 `decltype(auto)` ：不能结合指针、引用和 `cv` 限定符；使用在返回类型推导可以返回引用类型

- `C++17` 引入 `decltype(auto)` 作为非类型模板形参占位符

---

# **右值引用（C++11；C++17；C++20）**

- 能否取地址作为判断左右值的一个条件（还有生命周期作为参考）；字符串字面量可以取地址

- 左值引用：非常量只能引用左值，常量可以同时引用右值

- 值类别 

    ![20220316215313](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220316215313.png)

- 左值转换为右值： `C++11` 通过 `static_cast<T &&>` 和 `std::move` 转换

- 万能引用和引用折叠：右值引用 `auto &&` `T &&` 是万能引用（使用到引用折叠）

- 完美转发：右值引用的值实际上是左值；使用 `std::forward` 实现完美转发

- `C++20` 针对局部变量和右值引用的隐式移动操作

---

# **`lambda` 表达式（C++11～C++20）**

- `C++11` 

    ![20220316215756](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220316215756.png)

- 捕获列表的作用域

  - 捕获变量需要为非静态局部变量且为自动存储类型（静态局部变量和全局变量可以直接使用无需捕获）
  - 捕获的变量默认为常量（值捕获），可以使用 `mutable` 改变其常量性
  - `lambda` 表达式如果存在说明符，那么形参列表不能省略
  - 值捕获的变量在 `lambda` 表达式定义时已经固定下来
  - 特殊捕获： `[this]` `[=]` `[&]` 

- `C++14` 引入广义捕获

  - 分为简单捕获（ `C++11` ）和广义捕获（ `C++14` ）
  - `C++14` 允许捕获表达式结果以及自定义捕获变量名

- `C++14` 引入泛型 `lambda` 表达式：使用 `auto` 占位符定义推导形参类型

- `C++17` 引入常量 `lambda` 表达式和捕获 `*this` 

  - 对关键字 `constexpr` 的支持
  - 能够直接生成一个 `*this` 对象的副本保存在 `lambda` 表达式内

- `C++20` 捕获 `this` 指针： 使用 `[=, this]`

- `C++20` 引入模板语法的泛型 `lambda` 表达式： `[]<typename T>(T t) {}`

- `C++20` 支持可构造和可赋值的无状态 `lambda` 表达式 

---

# **非静态数据成员默认初始化（C++11；C++20）**

- `C++11` 之前使用初始化列表对非静态数据成员初始化

- `C++11` 允许使用 `=` `{}` 在声明非静态数据成员时初始化

  - 初始化列表优先于声明时默认初始化
  - 不使用括号 `()` 对非静态数据成员初始化
  - 不能使用 `auto` 声明和初始化非静态数据成员

- `C++20` 允许对数据成员的位域进行默认初始化

  ![20220317003311](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317003311.png)

  ---

  # **列表初始化（C++11；C++20）**

  - 使用括号叫直接初始化，使用等号叫拷贝初始化

  - 使用 `= {}` 或者 `({})` 为拷贝初始化；直接使用大括号 `{}` 为直接初始化

  - `std::initializer_list` 支持有 `begin` `end` 以及 `size` 的模板

  - 自定义类型的列表初始化（使用 `std::initializer_list` 作为形参）

  - 隐式窄缩转换：列表初始化不允许窄缩现象

  - `C++20` 提出指定初始化

    - 允许指定初始化数据成员的名称
    - 要求对象为聚合类型
    - 指定数据成员是非静态数据成员
    - 每个非静态数据成员最多只能初始化一次
    - 非静态数据成员的初始化要按照声明顺序进行
    - 针对联合体的数据成员只能初始化一次不同同时指定
    - 不能嵌套指定初始化数据成员
    - 使用指定的初始化后不能混用其他初始化方法

   ![20220317003934](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317003934.png)

---

# **非受限联合类型（C++11）**

- 联合类型成员可以是除了引用类型外的所有类型（特殊成员函数将被隐式删除）
- 有非平凡类型成员必须提供构造函数和折构函数（使用技巧）
- 静态成员需要在外部进行初始化

 ![20220317101813](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317101813.png)

 ---

 # **委托构造函数（C++11）**

 - 使用委托构造后不能在初始化列表里对数据成员和基类进行初始化
 - 委托模板构造函数：一个构造函数委托到同类型的一个模板构造函数
  
---

# **继承构造函数（C++11）**

- 使用 `using` 关键字引入基类的构造函数
- 在派生类中声明相同签名的构造函数会禁用继承相应的构造函数
- 派生类继承多个签名相同的构造函数会导致编译失败
- 继承构造函数的基类构造函数不能私有

---

# **强枚举类型（C++11；C++17；C++20）**

- `C++11` 定义

  - 枚举标识符属于强枚举类型的作用域
  - 枚举标识符不会隐式转换为整型
  - 能指定强枚举类型的底层类型（默认为 `int` ）
  - 在 `enum` 关键字后加上 `class` 关键字指定为强枚举类型
  - 使用 `: type` 指明底层类型为 `type` （适用于枚举类型和强枚举类型）
  - 强枚举类型不允许匿名

- `C++17` 允许列表初始化有底层类型枚举对象

- `C++20` 使用 `using` 打开强枚举类型的命名空间

---

# **扩展的聚合类型（C++17；C++20）**

- `C++17` 聚合类型定义
  - 没有用户提供的构造函数
  - 没有私有和受保护的非静态成员变量
  - 没有虚函数
  - 必须是公开的基类
  - 必须是非继承
- `C++17` 聚合类型的初始化：使用直接初始化；派生类存在多个基类，初始化顺序与继承顺序相同
- `C++20` 禁止聚合类型使用用户声明的构造函数
- `C++20` 使用带小括号的列表初始化聚合类型对象：即使用 `()` 初始化

---

# **`override` 和 `final` 说明符（C++11）**

- 重写（override）：派生类覆盖了基类的虚函数，需要相同的函数名、形参以及返回类型（返回类型协变除外）
- 重载（overload）：函数名相同但是函数签名（形参）不同（同一个类中）
- 隐藏（overwrite）：无论是否虚函数，当派生类出现同名函数，但是签名不同于基类函数
- 重写虚函数时，在重写的虚函数尾部写关键字 `override` 可以帮助检查错误
- 虚函数尾部加上关键字 `fianl` 可以防止虚函数被重写；声明类时使用可以防止该类被继承

---

# **基于范围的 `for` 循环（C++11；C++17；C++20）**

- `C++11` 引入
- `C++17` 对其改进（暂无记录）
- `C++20` 增加了对初始化语句的支持

![20220317104426](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317104426.png)
  
---

# **支持初始化语句的 `if` 和 `switch` （C++17）**

- 语法：支持 `if` 还有嵌套连续的 `if-else` 
- `switch` 语法等同

![20220317104550](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317104550.png)

---

# **`static_assert` 声明（C++11）**

- 运行时断言 `assert` 可以通过宏 `NDEBUG` 控制
- 传入两个参数：常量表达式和诊断消息字符串
- `C++17` 可以只传入常量表达式一个参数

---

# **结构化绑定（C++17；C++20）**

- 概念：将一个或多个名称绑定到初始化对象中的一个或多个子对象，相当于给初始化子对象起别名

- 语法： `auto [子对象1， 子对象2， ...] =`

- 结构化绑定可以用于三种类型：原生数组、结构体和类对象、元组和类元组的对象

- 原生数组：注意元素数量保持一致；数组不可退化为指针

- 结构体和类对象的条件

  - 类或结构体中的非静态数据成员个数必须和标识符列表的别名个数相同
  - 数据成员必须是公有的（ `C++20` 对此有修改）
  - 数据成员必须在同一个类或者基类中（不能跨越基类和派生类）
  - 绑定的类或结构体不能存在匿名联合体

- 元组和类元组对象的条件

  - 满足 `std::tuple_size<T>::value` 是一个符和语法的表达式
  - 且该表达式获得的整数值与标识符列表中的别名个数相同
  - 类型 T 应保证 `std::tuple_element<i, T>::type` 也是一个符合语法的表达式（表达式代表了类型 T 中的第 i 个元素的类型）
  - 类型 T 必须存在合法的成员函数模板 `get<i>()` 或函数模板 `get<i>(t)` ；t 是类型 T 的实例

- `C++20` 规定结构化绑定的数据成员不再要求是公开的

---

# **`noexcept` 关键字（C++11；C++17；C++20）**

- `noexcept` 对表达式的评估在编译期间，要求表达式为常量表达式

- `C++17` 将 `throw()` 作为 `noexcept` 的别名， `C++20` 又将其移除

- `C++11` 规定默认带有 `noexcept` 声明的函数

  - 默认复制构造函数
  - 默认赋值运算符
  - 默认移动构造函数
  - 默认移动赋值运算符
  - 折构函数（默认和用户自定义）
  - `delete` 运算符

- `C++17` 将异常规范引入类型系统：未声明 `noexcept` 的可以包含声明 `noexcept` ，反之不行

---

# **类型别名和别名模板（C++11；C++14）**

- 类型别名：使用 `typedef` 和 `using` （ `C++11` 引入）为类型起别名
- `using` 可以用于起别名模板

---

# **指针字面量 `nullptr` （C++11）**

- 纯右值：可以隐式转换为其他类型指针，但不能转为其他类型

---

# **三向比较（C++20）**

- 太空飞船运算符 `<=>` ：该返回值只能与0和自身类型比较；表达两个操作数是否相等或等价
- 如果用户为自定义类型声明了三向比较运算符，编译器会自动生成 `<` `>` `<=` `>=` 四种运算符
- 声明 `==` 运算符，则 `!=` 运算符会根据前者自动生成
- `std::rel_ops` 在 `C++20` 中不被推荐

---

# **线程局部存储（C++11）**

- 线程局部存储：对象内存在线程开始后分配，线程结束时回收且每个线程独立有该对象的实例
- `thread_local` 声明线程局部存储变量；通过 `static` 和 `extern` 指定内部链接性和外部链接性
- 其变量地址是运行时计算不是常量，无法与 `constexpr` 结合
- 线程局部存储对象只会初始化一次，对象销毁也只发生一次

---

# **扩展的 `inline` 说明符（C++17）**

- `C++17` 之前，类的非常量静态成员声明和定义需要分开；常量静态成员可以一边声明一边初始化
- `C++17` 增强 `inline` ，允许内联定义静态变量

---

# **常量表达式（C++11～C++20）**

- `C++11` 提出关键字 `constexpr` 定义常量表达式，在编译期计算

  - 用于函数时要求其返回值在编译期间能计算出来

  - 用于函数时要求

    - 必须返回一个值而不能是 `void` 
    - 函数体必须只有一条返回语句，语句必须是常量表达式
    - 函数使用之前必须有定义
    - 函数必须使用 `constexpr` 声明

  - 当传入参数非常量导致返回语句非常量表达式时，函数退化为普通函数

  - `constexpr` 构造函数：用 `constexpr` 声明；初始化列表必须是常量表达式；函数体为空

  - `constexpr` 会自动为函数带上 `const` 属性

  - 使用 `constexpr` 声明自定义类型变量

    - 必须确保折构函数是平凡的
    - 不能有用户自定义的折构函数
    - 折构函数不能是虚函数
    - 基类和成员的折构函数都必须是平凡的

  - 支持浮点类型的常量表达式

- `C++14` 增强

  - 函数体允许声明变量，除了初始化、`static` 和 `thread_local` 变量
  - 函数允许出现 `if` 和 `switch` 语句，不能用 `go` 语句
  - 允许所有的循环语句
  - 可以修改生命周期和常量表达式相同的对象
  - 返回值可以为 `void` 
  - `constexpr` 声明的成员函数不再具有 `const` 属性

- `C++17` 增强

  - `lambda` 表达式符合上述 `C++14` 条件时会隐式声明为 `constexpr` ，也可以显式声明
  - 使用 `constexpr` 声明静态成员变量时赋予该变量的内联属性
  - `static constexpr type valueName {initial};` 在 `C++11` 中只是声明， `C++17` 既是声明又是定义
  - 提出 `if constexpr (expression)` 编译期间能够确定结果的条件表达式；不支持短路规则 `&&` 

- `C++20` 增强

  - 允许虚函数使用 `constexpr` ；重写没有什么限制
  - 允许 `try-catch` 模块出现在 `constexpr` 函数中
  - 允许在 `constexpr` 中进行平凡的默认初始化
  - 允许更改联合类型的有效成员
  - 提出立即函数：在编译期间计算，不通过则报错而不是退化；使用 `consteval` 说明符（支持 `lambda` ）
  - 使用 `constinit` 检查常量初始化；用在具有静态存储持续时间的变量声明上，要求变量具有常量初始化程序
  - 引入 `std::is_constant_evaluated` 函数检查当前表达式是否是一个常量求值环境

---

# **确定的表达式求值顺序（C++17）**

- 暂无记录

---

# **字面量优化（C++11～C++17）**

- `C++11` 引入输出默认格式化
- `C++17` 支持使用十六进制浮点字面量表示一个浮点数
- `C++14` 定义二进制整数字面量（前缀 `0b` 或 `0B` ）
- `C++14` 支持单引号作为整数分割符
- `C++11` 支持原声字符串字面量： `R"(String)"` ；可以自定义分割符： `R"分割符()分割符"`
- `C++11` 支持 `wchar_t` `char16_t` `char32_t`；前缀分别为 `L` `u` `U`
- `C++20` 支持 `char8_t` ；前缀 `u8`
- `C++11` 引入用户自定义字面量：重载 `""` 操作符，后加空格和用户自定义后缀
- `C++11` 中用户自定义字面量中双引号和自定义后缀之间必须有空格； `C++14` 移除该限制

---

# **`alignas` 和 `alignof` （C++11；C++17）**

- `C++11` 新增关键字

  - `alignof` 接受类型作为参数
  - `alignas` 接受类型或常量表达式（常量表达式需要结果为 2 的幂值）作为参数
  - `std::align` 函数模板

- `C++17` 使用 `new` 分配指定对齐长度对象：编译器自动从类型对齐子节长度属性中获取并传参，不需要额外代码

---

# **属性说明符和标准属性（C++11～C++20）**

- 编译器自带属性（略）

- `C++11` 标准属性说明符： `[[属性1， 属性2， ...]]`

- `C++17` 使用 `using` 打开属性的命名空间：避免冲突，属性也支持命名空间

- `C++` 标准属性

  - `C++11` 引入 `[[noreturn]]` 用于表示函数不会返回到上一层调用的函数

  - `C++11` 引入 `[[carries_dependency ]]` 避免编译器生成不必要的内存栅栏（针对年弱内存顺序架构）

  - `C++14` 引入 `[[deprecated]]` 该属性的实体被声明为弃用，接受一个参数指明弃用原因

  - `C++17` 引入 `[[fallthrough]]` 提示编译器直落行为是有意的（ `case` 语句之间没有 `break` ）

  - `C++17` 引入 `[[nodiscard]]` 声明函数的返回值不应该被舍弃（返回引用不适用）

    - `C++20` 针对该属性支持将一个字符串字面量作为属性参数
    - `C++20` 针对该属性可以用于构造函数，在类型构造临时对象时发出警告

  - `C++17` 引入 `[[maybe_unused]]` 声明可能不被使用的对象以消除警告

  - `C++20` 引入 `[[likely]]` `[[unlikely]]` 声明在标签语句 `case` 上，允许对属性所在执行路径相对其他执行路径进行优化

  - `C++20` 引入 `[[no_unique_address]]` 针对非静态数据成员且不为位域的对象；指示该成员不需要为一的地址（用在无状态的类，即没有数据成员只有实现函数的类）作为数据成员加入其他类

---

# **新增预处理器和宏（C++17；C++20）**

- `C++17` 新增预处理器特性 `__has_include` ：判断某个头文件能否被包含进来

- `C++20` 新增测试功能特性的宏 `__has_cpp_attribute` 指示编译器环境是否支持某种属性（包括标准属性和厂商特有属性）

- `C++11` 纳入宏 `__VA_ARGS__` 可变参数宏，需要使用连接符 `##`

- `C++20` 纳入宏 `__VA_OPT__` 令可变参数宏更易于在可变参数为空时使用

  - `__VA_OPT__(,)` 说明逗号可选，可变参数不为空时使用逗号，为空时省略，用于取代连接符 `##`

---

# **协程（C++20）【复杂不理解】**

- 协程是一种可以被挂起和恢复的函数，提供一种创建异步代码的方法
- 具有任意关键字之一的函数就是协程 `co_await` `co_return` `co_yield` ； `main` 函数不能为协程
- `co_await` ：操作对象为可等待体（具备 `await_resume` `await_ready` `await_suspen` 三个曾元函数的对象）；可重载
- `co_yield` ：条件和下面一样
- `co_return` ：需要 `promise_type` 的支持，是一种结构，需要包含 `get_return_object` `initial_suspend` `final_suspend` `yield_value` `return_void` 或 `return_value(int value)` 等成员函数
- `promise_type` ：可以对 `co_await` 的操作数进行转换处理；可添加成语函数 `await_transform` ；还可以对异常进行处理，添加成员函数 `void set_exception` 

---  

# **基础特性的其他优化（C++11～C++20）**

- `C++11` 引入 `explicit` 说明符用于函数，要求其传递过程中使用显式类型转换；部分例外如下

  ![20220317140758](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317140758.png)

- `C++17` 引入 `std::launcher()` 

  - 如果新的对象在已被某个对象占用的内存上进行构建，那么原始对象的指针、引用以及对象名都会自动转向新的对象，除非对象是一个常量类型或对象中有常量数据成员或者引用类型

- 返回值优化

  - 返回值优化的条件：复制构造函数必须是可访问的
  - `C++14` 明确对于常量表达式和常量初始化，编译器应该保证 `RVO` 禁止 `NRVO`
  - `C++17` 指出：传递临时对象或者从函数返回临时对象的情况下，编译器应该省略对象的复制和移动构造函数，即使这些复制和移动构造还有一些额外的作用，最终还是直接将对象构造到目标的存储变量上，从而避免临时对象的产生。标准还强调，这里的复制和移动构造函数甚至可以是不存在或者不可访问的

- `C++20` 允许按值进行默认比较：在 `C++20` 之前的标准中，类的默认比较规则要求类 C 可以有一个参数为 `const C&` 的非静态成员函数，或者有两个参数为 `const C&` 的友元函数； `C++20` 规定类的默认比较运算符函数可以是一个参数为 `const C&` 的非静态成员函数，或是两个参数为 `const C&` 或 C 的友元函数

- `C++20` 支持 `new` 表达式推导数组长度： 使用 `new` 时支持按照元素个数推导数组长度

- `C++20` 允许数组转换为未知范围的数组

  ![20220317141312](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317141312.png)

- `C++20` 支持在 `delete` 运算符中折构对象：将内存删除与折构对象分开，允许用户控制（通过重载 `delete` 运算符）

- `C++20` 中伪折构函数的调用总是会结束对象的生命周期，即使对象是一个平凡类型

- `C++20` 修复 `const` 和默认复制构造函数不匹配造成无法编译的问题

- `C++20` 不推荐使用 `volatile` 

- `C++20` 不推荐在下标表达式中使用逗号运算符

- `C++20` 引入模块

    ![20220317141753](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317141753.png)

---

# **可变参数模板（C++11；C++17；C++20）**

- `C++11` 引入可变参数模板（类和函数）

  - `class... Args` 是类型模板形参包，可以接受零个或多个类型的模板实参

  - `Args... args` 是函数形参包，接受零个或多个函数实参

  - `args...` 是形参包展开，成为解包

  - 类模板中，模板形参包必须是模板形参列表的最后一个形参

  - 函数模板中，模板形参包不必出现在最后，只要保证后续形参类型能够通过实参推导或具有默认参数即可

  - 非类型模板形参也可以作为形参包

  - 形参包展开允许场景

    ![20220317142556](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317142556.png)

  - `sizeof...` 运算符：获取形参包的形参个数

- `C++17` 引入折叠表达式

  - 类别：一元向左折叠、一元向右折叠、二元向左折叠、二元向右折叠

  - 折叠规则：二元折叠中，两个运算符必须相同

  - 一元折叠表达式中空参数包的特殊处理

    ![20220317142758](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317142758.png)

- `C++17` 包展开允许出现在 `using` 声明的列表内

- `C++20` 支持 `lambda` 表达式初始化捕获的包展开

---

# **`typename` 优化（C++17；C++20）**

- `C++17` 允许使用 `typename` 声明模板形参
- `C++20` 省略 `typename` 的情况：上下文仅可能是类型标识的情况；声明的情况

---

# **模板参数优化（C++11；C++17；C++20）**

- `C++17` 允许常量求值作为所有非类型模板的实参

  - `C++17` 标准之前实参都强调链接和静态
  - 非类型模板形参使用的实参可以是该模板形参类型的任何经转换常量表达式
  - 经转换常量表达式的定义添加了对象、数组、函数等到指针的转换

- `C++11` 允许局部和匿名类型作为模板实参

- `C++11` 允许函数模板的默认模板参数

  - 函数的默认参数和类模板的默认模板参数都必须保证从右到左定义默认值
  - 函数模板默认模板类型没有该限制

- `C++20` 的函数模板添加到 `ADL` 查找规则

- `C++20` 允许非类型模板型形参中的字面量类类型

  - 所有基类和非静态数据成员都是公开且不可变的
  - 所有基类和非静态数据成员的类型是标量类型、左值引用或前者的数组

- `C++17` 扩展的模板参数匹配规则：要求模板形参至少和实参列表一样特化

---

# **类模板的模板实参推导（C++17；C++20）**

- `C++17` 支持模板的模板实参推导（模板参数类型）：类模板不支持部分指定类型

  ![20220317150517](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317150517.png)

- `C++20` 提出拷贝初始化优先

  - 当且仅当初始化列表只有一个与目标类模板相同的元素才触发拷贝初始化
  - 将一个结构的数据拷贝到另一个结构，而不是作为其元素
  - 其他情况创建一个新的类型，将一个结构作为该结构的元素

- `C++17` 类模板支持模板类型自动推导，可以将 `lambda` 表达式作为参数

- `C++20` 支持别名模板的类模板实参推导

- `C++20` 支持聚合类型的类模板实参推导（结构体）

---

# **用户自定义推导指引（C++17）**

- 在类名和参数列表后使用 `-> 类名 （形参类型）` 来指引参数类型推导
- 编译器优先选择用户自定义推导指引

---

# **`SFINA` （C++11）**

- 概念：替换失败不是错误；函数模板重载时，当模板形参替换为指定的实参或函数实参推导出模板形参的过程中出现失败，则放弃该重载而不是抛出编译失败

- 在直接上下文中使用模板实参替换形参后，类型或表达式不符合语法，则替换失败

- 替换后在非直接上下文中产生的副作用导致的错误则被当作编译错误

- 编译错误

  - 处理表达式外部某些实体时发生的错误，比如实例化某模板或生成某隐式定义的成员函数等
  - 由于实现限制导致的错误
  - 由于访问违规导致的错误
  - 由于同一个函数的不同声明的词法顺序不同，导致替换顺序不同或者根本无法替换

- 可以用在重载版本的选择

---

# **概念和约束（C++20）**

- 使用 `std::enable_if` 约束模板

- 概念：在编译时进行评估，对类模板、函数模板以及类模板的成员函数进行约束

- 使用 `concept` 关键字； `requires` 关键字也可以起到相同作用

- `requires` 子句除了出现在模板形参列表尾部，还可以出现在函数模板声明尾部

- 约束条件优先级

  ![20220317151726](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317151726.png)

- 原子约束：表达式和表达式中模板形参到模板实参映射的组合

  - 简单要求：不以 `reuqires` 关键字开始的要求，只断言表达式的有效性不做求值操作
  - 类型要求：以 `typename` 关键字开始的要求，紧跟类型名
  - 复合要求：可以由3部分组成： `{}` 中的表达式、 `noexcept` 以及 `->` 后的返回类型约束（后两者可选）
  - 嵌套要求：以 `requires` 开始的要求，通常根据局部形参来指定额外的要求

- 约束可变参数模板

- 约束类模板特例化

- 约束 `auto` ：使用一个模板创建一个约束，约束之后必须紧跟 `auto` 关键字

  ![20220317152136](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317152136.png)

---

# **模板特例化的其他优化（C++11；C++14）**

- `C++11` 引入外部模板：使用 `extern` 声明一个外部模板，但不进行实例化

- `C++11` 对连续右尖括号的优化

- `C++11` 声明友元类忽略 `class` 关键字（该友元类必须提前声明）

- `C++14` 提出变量模板

  ![20220317152419](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317152419.png)

- `C++17` 使用 `std::is_same_v<>` 判断两个类型是否相等

- `C++20` 新增 `explicit(bool)` 接受一个求值类型为 `bool` 的常量表达式，指定 `explicit` 的功能是否生效