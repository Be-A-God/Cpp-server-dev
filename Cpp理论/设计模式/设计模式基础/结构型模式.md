# **装饰者模式**

- 概念：通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为

- 应用场景

  - 无需修改代码情况下新增对象行为
  - 继承不可用时（如使用 `final` 限定的类）

- 角色

  - 部件：声明封装器和被封装对象的公用接口
  - 具体部件：是被封装对象所属的类，定义了基础行为
  - 基础装饰：拥有一个指向被封装对象的引用成员变量，操作委托给被封装对象
  - 具体装饰：定义了可动态添加到部件的额外行为
  - 客户端：使用多层装饰来封装部件

- 优缺点

  - 优点
  
    - 无需创建新子类
    - 运行时添加或删除功能
    - 多个装饰对象组合行为
    - 单一职责

  - 缺点

    - 在封装器栈中删除特定封装器比较困难
    - 实现行为不受装饰栈顺序影响的装饰比较困难
    - 各层的初始化配置代码看上去可能会很糟糕

- [实现](https://github.com/Be-A-God/Cpp-server-dev-code/tree/main/GoF23/Strucutral/Decorator)

---

# **适配器模式**

- 概念：使接口不兼容的对象能够相互合作

- 角色

  - 客户端：包含当前程序业务逻辑的类
  - 客户端接口：描述了其他类与客户端代码合作时必须遵循的协议
  - 服务：无法直接调用的功能类
  - 适配器：实现客户端与服务之间适配交互的类

- 优缺点

  - 优点

    - 单一职责
    - 开闭

  - 缺点

    - 代码整体复杂度增加


- [实现](https://github.com/Be-A-God/Cpp-server-dev-code/tree/main/GoF23/Strucutral/Adapter)

---

# **组合模式**

- 概念：将对象组合成树状结构， 并且能像使用独立对象一样使用它们

- 角色

  - 组件：描述了树中简单项目和复杂项目所共有的操作
  - 叶节点：树的基本结构，不包含子项目，完成大部分实际工作
  - 容器：包含叶结点和其他容器等子项目的单位
  - 客户端：通过组件接口和所有项目交互

- 应用场景

  - 实现树状对象结构
  - 客户端代码以相同方式处理简单和复杂元素

- 优缺点

  - 优点

    - 开闭
    - 多态和递归使用复杂树结构

  - 缺点

    - 功能差异大的类，提供公共接口有困难

- [实现](https://github.com/Be-A-God/Cpp-server-dev-code/tree/main/GoF23/Strucutral/Composite)
