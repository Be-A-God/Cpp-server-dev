# **单例模式**

- 概念：保证一个类仅有一个实例，并提供一个访问它的全局访问点

- 应用场景 

  - 频繁创建及销毁的对象，例如工具类
  - 不变的对象
  - 重量级对象
  - 线程池，缓存
  - 打印机，日志对象

- 优缺点

  - 优点

    - 对单例类的所有实例化得到的都是同一个实例，确保所有对象都访问同一个实例
    - 具有一定的伸缩性，由类自己来控制实例化进程
    - 提供了对唯一实例的受控访问
    - 只存在一个对象，节省系统资源
    - 避免对共享资源的多重占用

  - 缺点

    - 不适用于变化的对象
    - 没有抽象层，扩展有难度
    - 单例职责过重，违反“单一职责原则”

- 注意事项

  - 使用时不能用反射模式创建单例，否则会实例化一个新对象
  - 使用懒汉模式时注意线程安全问题
  - 构造方法是私有的不能被继承，构造方法为 `protected` 即可被继承

- 实现 

  - [懒汉模式](https://github.com/Be-A-God/Cpp-server-dev-code/blob/main/GoF23/singleton_pattern/lazy_man.hpp)

    - 存在线程安全、内存泄漏（简单判空）
    - 解决线程安全、内存泄漏（双检锁/原子操作/call_once，智能指针/嵌套类/友元类）
    - 静态局部变量（解决线程安全和内存泄漏最简单的方法，C++11之后支持）

  - [饿汉模式](https://github.com/Be-A-God/Cpp-server-dev-code/blob/main/GoF23/singleton_pattern/hungry_man.hpp)

    - 静态对象
    - 静态指针（考虑内存回收）

  - [单例模板](https://github.com/Be-A-God/Cpp-server-dev-code/blob/main/GoF23/singleton_pattern/template.hpp)

    - `CRTP` 奇异递归模板
    - 无需子类中声明友元（定义一种外界无法访问的自定义类型用于构造函数形参）

---

# **工厂方法模式**

- 概念：定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类；工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象

- 角色

  - 抽象产品：对接口进行声明
  - 具体产品：产品接口的不同实现
  - 抽象工厂：类声明返回产品对象的工厂方法（可以抽象或者返回一种默认产品）
  - 具体工厂：重写基础工厂方法，使其返回不同类型产品
  - 客户端

- 应用场景

  - 无法预知对象确切类别及其依赖关系
  - 用户能够扩展其内部组件
  - 复用现有对象而不是重新创建对象

- 优缺点

  - 优点

    - 避免创建者和具体产品之间的紧密耦合
    - 单一职责原则，客户端不负责对象的创建，而是把创建任务交给了具体的工厂类，客户端只是负责对象的调用，从而明确了各个类的职责
    - 开闭原则，如果有新产品加入，只须用创建一个具体的工厂类和产品类就可以了

  - 缺点

    - 引入许多新子类，代码会因此变复杂

- [实现](https://github.com/Be-A-God/Cpp-server-dev-code/blob/main/GoF23/factory_pattern/method.hpp)

---

# **抽象工厂模式**

- 概念：提供一个创建一系列相关或相互依赖的接口，而无需指定他们具体的类

- 应用场景

  - 与多个不同系列的产品交互，但无法提前获取相关信息，不希望代码基于产品的具体类进行构建

- 优缺点

  - 优点

    - 单一职责
    - 开闭
    - 避免客户端和具体产品代码耦合

  - 缺点

    - 引入众多接口和类

- 角色

  - 抽象产品：为构成系列产品的一组不同但相关的产品声明接口
  - 具体产品：是抽象产品的多种不同类型实现
  - 抽象工厂：接口声明了一组创建各种抽象产品的方法
  - 具体工厂：实现抽象工厂的构建方法
  - 客户端：只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互

- 注意事项

- [实现](https://github.com/Be-A-God/Cpp-server-dev-code/blob/main/GoF23/factory_pattern/abstract.hpp)

---

# **建造者模式**

- 概念：分步骤创建复杂对象。该模式允许你使用相同的创建代码生成不同类型和形式的对象

- 应用场景

  - 避免重叠构造函数的出现
  - 创建不同形式的产品
  - 构造组合树或者其他复杂对象

- 优缺点

  - 优点

    - 分步创建对象
    - 复用相同的制造代码
    - 单一职责

  - 缺点

    - 需要新增多个类

- 角色

  - 生成器：接口声明在所有类型生成器中通用的产品构造步骤
  - 具体生成器：提供构造过程的不同实现
  - 产品：最终生成的对象
  - 主管：类定义调用构造步骤的顺序
  - 客户端：必须将某个生成器对象和主管类关联

- [实现](https://github.com/Be-A-God/Cpp-server-dev-code/blob/main/GoF23/Builder/main.cpp)

---

# **原型模式**

- 概念：能够复制已有对象， 而又无需使代码依赖它们所属的类

- 应用场景

  - 复制对象而又独立于这些对象所属的具体类
  - 子类的区别仅在于其对象的初始化方式

- 角色

  - 原型：接口对克隆方法进行声明
  - 具体原型：类实现克隆方法
  - 客户端：复制实现了原型接口的任何对象

- 优缺点

  - 优点

    - 克隆对象而不需与所属类相耦合
    - 更方便生成复杂对象

  - 缺点

    - 克隆包含循环引用的复杂对象会非常麻烦

- [实现](https://github.com/Be-A-God/Cpp-server-dev-code/blob/main/GoF23/Builder/main.cpp)

---

# **简单工厂模式**（不属于GoF23但属于创建型模式）

- *违反单一职责、开放封闭原则*

- 概念：用单独的类来创建其它类的实例的一种创建型模式；实质是工厂类根据传入的参数，来动态决定创建哪一个产品的实例

- 应用场景

  - 工厂类负责创建的产品比较少且创建的产品不经常变更
  - 客户端需要知道传入工厂类的参数，不需要关心如何创建对象

- 优缺点

  - 优点

    - 客户端与具体实现类解耦
    - 不用考虑对象的创建过程

  - 缺点

    - 增加功能是通过修改源代码实现，不符合开放封闭原则
    - 类的职责过重，不符合单一职责原则

- 角色

  - 工厂角色：负责实现创建所有实例的内部逻辑
  - 抽象产品角色：所创建的所有对象的父类，负责描述所有实例所共有的公共接口
  - 具体产品角色：创建目标，所有创建的对象

- [实现](https://github.com/Be-A-God/Cpp-server-dev-code/blob/main/GoF23/factory_pattern/simple.hpp)
