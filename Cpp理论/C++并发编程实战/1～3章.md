# **第一章**

- 并发：两个或多个同时独立进行的活动
- 并发方式：多进程并发/多线程并发；C++只支持多线程并发
- 并发与并行：并发关心分离关注点或响应能力；并行关心利用可调配的硬件资源提升大规模数据处理的性能
- 并发：任务并行和数据并行
- 任务并行：将单一任务分解成多个部分各自运行
- 数据并行：对数据的不同部分执行同样的操作
- 每个线程都需要独立的栈空间
- 通常32位机器进程中，可用空间是4GB，线程栈大小通常为1MB
- 线程越多，上下文切换越频繁
- 每个线程都需要一个起始函数，新线程从这个函数开始执行（可以是任何函数对象）
- 应用程序的起始线程是main函数
- 新线程通过构造 `std::thread` 对象创建（构造时指明函数对象）
- 成员函数 `join()` 等待线程结束

---

# **第二章 线程管控**

- C++最麻烦的解释：传入临时变量时，容易将定义对象解释成函数声明
- 解决：使用列表初始化、使用两对圆括号、使用lambda表达式
- `std::thread` 对象销毁之前需要设定线程汇合或分离，否则该对象折构时调用 `std::terminate` 终止程序
- 线程分离：对象销毁后线程仍旧运行，只有最终从线程函数返回时才结束运行；使用成员函数 `detach`
- 线程分离时注意对销毁对象的非法访问
- 线程汇合：使用成员函数 `join` 等待线程结束，只能调用一次
- 使用成员函数 `joinable` 判断线程是否能够汇合或分离
- 线程启动后有异常抛出，而 `join` 尚未执行，则该 `join` 将被略过
- 解决：使用标准的RAII手法，在其折构函数中调用 `join` ；对 `std::thread` 对象的封装；注意删除拷贝函数和运算符
- 分离的线程由C++运行时库控制
- 分离线程通常称为守护线程
- 线程对象可以接受多个参数，参数会被复制当成临时变量，以右值形式传递（即使是引用）
- 线程对象接受的多个参数与线程函数对应
- 线程对象需要接受引用参数，需要使用 `std::ref` 
- 将类成员函数设为线程函数：传入一个函数指针指向该成员（成员函数名不能代表函数入口）和对象指针作为该函数的第一个参数，后续参数作为成员函数的参数
- 移动语义传参：原对象是临时变量则自动移动，原对象是具名变量则需要使用 `std::move`
- `std::thread` 对象正掌控着一个线程，若向其赋新值则会导致该线程被遗弃
- C++20引入新类，其线程对象在折构时能够自动汇合
- 使用容器存放线程对象
- 返回运行中可真正并发的线程数量： `std::thread::hardware_concurrency`
- 无法从线程中直接返回值，每个线程都内建了唯一的线程ID
- 识别线程： `std::thread::id` ，通过成员函数 `get_id` 获得或者 `std::this_thread::get_id` 
- 线程ID可以随意进行复制和比较，比较建立了全序关系（反对称、传递和完全）
- 线程ID可以用作关联容器的键值实现主控线程管理多个线程

---

# **第三章 在线程间共享数据**

- 数据竞争：并发改动单个对象而形成的特定的条件竞争
- 最简单的解决：互斥mutex
- 使用 `std::mutex` 创建互斥，成员函数 `lock` 进行加锁，成员函数 `unlock` 进行解锁
- 推荐使用类模板 `std::lock_guard<>` 进行互斥加锁：构造时加锁，折构时解锁
- C++17引入类模板参数推导，简化为 `std::lock_guard()` 
- C++17引入增强版的 `std::scoped_lock`
- 注意屏蔽受保护数据的额外访问方式：引用和指针
- 接口固有的条件竞争
- 死锁：进行某项操作而对多个互斥加锁诱发的问题
- 防范死锁：始终按相同顺序对两个互斥加锁； `std::lock` 同时锁住多个互斥而没有死锁的风险
- `std::adopt_lock` 对象指明互斥已被锁住， `std::lock_guard` 实例应当接收锁的归属而不是重新加锁
- `std::lock` 对多个锁要么全部成功要么全部失败，即使抛出异常，有效避免死锁
- C++17改进的 `std::scoped_lock` 接收多个锁，且构造函数完成时对所有对象上锁（区别于 `std::lock_guard` 只能对单一对象上锁）
- 防范死锁的准则：避免嵌套锁、持锁时避免调用由用户提供的程序接口、依从固定顺序获取锁、按层级加锁、其他同步操作也应如此
- `std::try_lock` 函数：若另一线程在目标互斥上持有锁，则函数返回 `false`
- `std::unique_lock<>` 对象不一定始终占有与之关联的互斥；其构造函数接收第二个参数 `std::adopt_lock` 实例或 `std::defer_lock` 实例
- `std::unique_lock` 适用于延时加锁和转移锁的归属权
- `std::unique_lock` 对象管理互斥上的锁，传入 `std::defer_lock` 实例可以在该对象构造时处于无锁，延时在调用 `std::lock` 对该对象（不是互斥对象）加锁
- 锁的互斥归属权：左值转移需要显式地移动语义，右值可以隐式转移
- `std::unique_lock` 能够在实例销毁前手动解锁
- 非必要不在持锁期间进行 `I/O` 或获取另一个锁
- 仅在初始化过程中保护共享数据：`Double-Check` 不适合（在单例模式中有分析）
- 使用 `std::once_flag` 和 `std::call_once` 进行单次的语句执行（同样在单例模式中使用到）
- C++11规定静态数据在初始化完成之前，其他线程不会越过静态数据的声明继续执行（单例模式里用法）
- 读写互斥：允许单个“写进程”或单个“读进程”
- C++17支持的读写互斥：`std::shared_mutex` 和 `std::shared_timed_mutex` （后者支持更多操作，但有性能影响）
- C++14支持的读写互斥：`std::shared_timed_mutex` 
- C++11暂无支持的互斥类型
- `std::shared_lock` 允许多个线程同时锁住同一个 `std::shared_mutex` ；该共享锁被持有时阻塞排他锁的获取；任一线程持有排他锁，则其他线程无法获取共享锁或排他锁
- `std::recurisive_mutex` 允许同一线程对某互斥的同一实例多次加锁（不推荐）
- 共享锁即读锁，排他锁即写锁