# **本章内容**

- C++内存模型详述
- C++标准库提供的原子类型
- 适用于这些原子类型的操作
- 如何利用以上操作实现线程间同步

---

# **内存模型基础**

        内存模型牵涉两个方面：基本结构和并发。基本结构关系到整个程序在内存中的布局

- 对象和内存区域

        每个变量都是对象，对象的数据成员也是对象；每个对象都占用至少一块内存区域；若变量属于内建基本类型（如int或char），则不论其大小，都占用一块内存区域（且仅此一块），即便它们的位置相邻或它们是数列中的元素；相邻的位域属于同一内存区域

- 对象、内存区域和并发

        假设两个线程访问同一内存区域，却没有强制它们服从一定的访问次序，如果其中至少有一个是非原子化访问，并且至少有一个是写操作，就会出现数据竞争，导致未定义行为。凡是涉及数据竞争的内存区域，我们都通过原子操作来访问，即可避免未定义行为

- 改动序列

         在一个C++程序中，每个对象都具有一个改动序列，它由所有线程在对象上的全部写操作构成，其中第一个写操作即为对象的初始化。在程序的任意一次运行过程中，所含的全部线程都必须形成相同的改动序列

---

# **C++中的原子操作及其类别**

    原子操作是不可分割的操作（indivisible operation）。在系统的任一线程内，我们都不会观察到这种操作处于半完成状态；它或者完全做好，或者完全没做。与之相反，非原子操作（non-atomic operation）在完成到一半的时候，有可能为另一线程所见

- 标准原子类型

        原子操作的关键用途是取代需要互斥的同步方式。实现无锁访问

        从C++17开始，全部原子类型都含有一个静态常量表达式成员变量（static constexpr member variable），形如X::is_always_lock_free，功能与那些宏相同：考察编译生成的一个特定版本的程序，当且仅当在所有支持该程序运行的硬件上，原子类型X全都以无锁结构形式实现，该成员变量的值才为true

        假设某原子类型从来都不属于无锁结构，那么，对应的宏取值为0；若它一直都属于无锁结构，则宏取值为2；如果像前文所述，等到运行时才能确定该原子类型是否属于无锁结构，就取值为1

        只有一个原子类型不提供is_lock_free()成员函数：std::atomic_flag。它是简单的布尔标志（boolean flag），因此必须采取无锁操作

        由于不具备拷贝构造函数或拷贝赋制操作符，因此按照传统做法，标准的原子类型对象无法复制，也无法赋值。然而，它们其实可以接受内建类型赋值，也支持隐式地转换成内建类型，还可以直接经由成员函数处理，如load()和store()、exchange()、compare_exchange_weak()和compare_exchange_strong()等。它们还支持复合赋值操作，如+=、−=、*=和|=等。而且，整型和指针的std::atomic<>特化都支持++和−−运算。这些操作符有对应的具名成员函数，fetch_add()和fetch_or()等。赋值操作符的返回值是存入的值，而具名成员函数的返回值则是进行操作前的值。习惯上，C++的赋值操作符通常返回引用，指向接受赋值的对象，但原子类型的设计与此有别，要防止暗藏错误。否则，为了从引用获得存入的值，代码须执行单独的读取操作，使赋值和读取操作之间存在间隙，让其他线程有机可乘，得以改动该值，结果形成条件竞争

        对于原子类型上的每一种操作，我们都可以提供额外的参数，从枚举类std::memory_order取值，用于设定所需的内存次序语义

        存储（store）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_release或std::memory_order_seq_cst。
        
        载入（load）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire或std::memory_order_seq_cst。
        
        “读-改-写”（read-modify-write）操作，可选用的内存次序有std::memory_order_relaxed、std::memory_order_consume、std::memory_order_acquire、std::memory_order_release、std::memory_order_acq_rel或std::memory_order_seq_cst

- 操作 `std::atomic_flag`

        std::atomic_flag是最简单的标准原子类型，表示一个布尔标志。该类型的对象只有两种状态：成立或置零。二者必居其一 

        std::atomic_flag类型的对象必须由宏ATOMIC_FLAG_INIT初始化，它把标志初始化为置零状态：std::atomic_flag f=ATOMIC_FLAG_INIT。无论在哪里声明，也无论处于什么作用域，std::atomic_flag对象永远以置零状态开始，别无他选。全部原子类型中，只有std::atomic_flag必须采取这种特殊的初始化处理，它也是唯一保证无锁的原子类型

        如果std::atomic_flag对象具有静态存储期（static storageduration）[5]，它就会保证以静态方式初始化，从而避免初始化次序的问题（initialization-order issue）。对象在完成初始化后才会操作其标志

        完成std::atomic_flag对象的初始化后，我们只能执行3种操作：销毁、置零、读取原有的值并设置标志成立。这分别对应于析构函数、成员函数clear()、成员函数test_and_set().我们可以为clear()和test_and_set()指定内存次序。clear()是存储操作，因此无法采用std::memory_order_acquire或std::memory_order_acq_rel内存次序，而test_and_set()是“读-改-写”操作，因此能采用任何内存次序。对于上面两个原子操作，默认内存次序都是std::memory_order_seq_cst

        我们无法从std::atomic_flag对象拷贝构造出另一个对象，也无法向另一个对象拷贝赋值，这两个限制并非std::atomic_flag独有，所有原子类型都同样受限。原因是按定义，原子类型上的操作全都是原子化的，但拷贝赋值和拷贝构造都涉及两个对象，而牵涉两个不同对象的单一操作却无法原子化。在拷贝构造或拷贝赋值的过程中，必须先从来源对象读取值，再将其写出到目标对象。这是在两个独立对象上的两个独立操作，其组合不可能是原子化的。所以，原子对象禁止拷贝赋值和拷贝构造

        正因为std::atomic_flag功能有限，所以它可以完美扩展成自旋锁互斥（spin-lockmutex）。最开始令原子标志置零，表示互斥没有加锁。我们反复调用test_and_set()试着锁住互斥，一旦读取的值变成false，则说明线程已将标志设置成立（其新值为true），则循环终止。而简单地将标志置零即可解锁互斥

- 操作 `std::atomic<bool>`

        尽管std::atomic<bool>也无法拷贝构造或拷贝赋值，但我们还是能依据非原子布尔量创建其对象，初始值是true或false皆可。该类型的实例还能接受非原子布尔量的赋值.非原子布尔量也可以向std::atomic<bool>赋值，但该赋值操作符的行为有别于惯常做法：它直接返回赋予的布尔值

        原子类型的又一个常见模式：它们所支持的赋值操作符不返回引用，而是按值返回（该值属于对应的非原子类型）

        store()是存储操作，而load()是载入操作，但exchange()是“读-改-写”操作

        成员函数compare_exchange_weak()和compare_exchange_strong(),若原子对象当前的值符合预期，就赋予新值.

        比较-交换函数还有一个特殊之处：它们接收两个内存次序参数。这使程序能区分成功和失败两种情况，采用不同的内存次序语义。合适的做法是：若操作成功，就采用std::memory_order_acq_rel内存次序，否则改用std::memory_order_relaxed内存次序。失败操作没有存储行为，所以不可能采用std::memory_order_release内存次序或std:: memory_order_acq_rel内存次序。因而这两种内存次序不准用作失败操作的参数。失败操作设定的内存次序不能比成功操作的更严格；若将失败操作的内存次序指定为std::memory_order_acquire或std::memory_order_seq_cst，则要向成功操作设定同样的内存次序

        std::atomic<bool>和std::atomic_flag的另一个不同点是，前者有可能不具备无锁结构，它的实现可能需要在内部借用互斥，以保证操作的原子性。这通常不成问题，但保险起见，我们还可以调用成员函数is_lock_free()，检查std::atomic<bool>是否具备真正的无锁操作。除std::atomic_flag之外，所有原子类型都提供这项检查功能

- 操作 `std::atomic<T*>` ：算术形式的指针运算

        不能拷贝复制或拷贝赋值。然而，只要依据适合的指针，就可以创建该原子类型的对象，接受其赋值。根据类模板的定义，std::atomic<T*>也具备成员函数is_lock_free()、load()、store()、exchange()、compare_exchange_weak()和compare_exchange_strong() ，它们与std::atomic<bool>中的对应函数有着相同的语义，但接收的参数和返回值不再是布尔类型，而是T*类型

        std::atomic<T*>提供的新操作是算术形式的指针运算。成员函数fetch_add()和fetch_sub()给出了最基本的操作，分别就对象中存储的地址进行原子化加减。另外，该原子类型还具有包装成重载运算符的+=和−=，以及++和−−的前后缀版本

        fetch_add()和fetch_sub()则稍微不同，它们返回原来的地址。因此，操作x.fetch_add(3)会更新x，令其指向数组第四项，但返回的指针则指向第一项。该操作又名“交换相加”（exchange-and-add），与exchange()和compare_exchange_weak()/compare_exchange_strong()同属一类，也是一种“读-改-写”操作。与其他原子操作相同，它返回T*型的普通指针

- 操作标准整数原子类型

        包括常用的原子操作（load()、store()、exchange()、compare_exchange_weak()和compare_exchange_strong()），也包括原子运算（fetch_add()、fetch_sub()、fetch_and()、fetch_or()、fetch_xor()），以及这些运算的复合赋值形式（+=、−=、&=、|=和^=），还有前后缀形式的自增和自减（++x、x++、−−x和x−−）

        具名函数按原子化方式执行操作，并返回原子对象的旧值，然而复合赋值运算符则返回新值。前后缀形式的自增和自减都按既有方式工作：++x令变量自增，并返回新值；x++也令变量自增，但返回旧值

        全都返回对应的内置整型值

- 泛化的 `std::atomic<>` 类模板

        对于某个自定义类型UDT，要满足一定条件才能具现化出std::atomic<UDT>：必须具备平实拷贝赋值操作符（trivial copy-assignment operator）[8]，它不得含有任何虚函数，也不可以从虚基类派生得出，还必须由编译器代其隐式生成拷贝赋值操作符；另外，若自定义类型具有基类或非静态数据成员，则它们同样必须具备平实拷贝赋值操作符

        比较-交换操作所采用的是逐位比较（bitwise comparison）运算，效果等同于直接使用memcmp()函数。即使UDT自行定义了比较运算符，在这项操作中也会被忽略。若自定义类型含有填充位（padding bit）[9]，却不参与普通比较操作，那么即使UDT对象的值相等，比较-交换操作还是会失败

        内在因素可能导致compare_exchange_weak()失败。即便原子类型内本来存有的值与比较的值相等，若两个值的表示方式不同[10]，依然会令函数操作失败。请注意，浮点值的算术原子运算并不存在。假设我们用某个自定义类型特化std::atomic<>，而该类型定义了自己的等值比较运算符重载，它的判别方式与memcmp()不同，如果我们就这一特化调用compare_exchange_strong()，那么该函数的行为与处理浮点原子类型的情况类似，虽然参与比较的两个值相等，但比较-交换操作还是会因表示方式不同而失败

- 原子操作的非成员函数

        还有众多非成员函数，与各原子类型上的所有操作逐一等价。大部分非成员函数依据对应的成员函数命名，只不过冠以前缀“atomic_”（如std::atomic_load()），它们还针对各原子类型进行了重载。只要有可能指定内存次序，这些函数就衍化出两个变体：一个带有后缀“_explicit”，接收更多参数以指定内存次序，而另一个则不带后缀也不接收内存次序参数.所有非成员函数的第一个参数都是指针，指向所要操作的目标原子对象

        根据C++标准的设计，这些非成员函数要兼容C语言，所以它们全都只接收指针，而非引用

        非成员函数std::atomic_compare_exchange_weak_explicit()则没有重载版本，须同时为两种情况各自设定内存次序(失败和成功)

        atomic_shared_ptr<>被设计成一个独立类型，因为按照这种形式，它有机会通过无锁方式实现，而且比起普通的std::shared_ptr对象，它没有增加额外开销。但是在目标硬件平台上，我们仍需查验它是否属于无锁实现，这可以由成员函数is_lock_free()判定，与类模板std::atomic<>上的做法相同。在多线程环境下处理共享指针，我们要避免采用普通的std::share_ptr类型，也不要通过非成员原子函数对其进行操作(C++20支持)

---

# **同步操作和强制次序**

- 同步关系

- 先行关系

- 原子操作的内存次序

        原子类型上的操作服从 6 种内存次序：memory_order_relaxed、memory_order_consume、memory_order_acquire、memory_order_release、memory_order_acq_rel和memory_order_seq_cst。其中，memory_order_seq_cst是可选的最严格的内存次序，各种原子类型的所有操作都默认遵从该次序，除非我们特意为某项操作另行指定

        虽然内存次序共有6种，但它们只代表3种模式：先后一致次序（memory_order_seq_cst）、获取-释放次序（memory_order_consume、memory_order_acquire、memory_order_release和memory_order_acq_rel）、宽松次序（memory_order_relaxed）

    - 先后一致次序memory_order_seq_cst

            默认内存次序之所以命名为“先后一致次序”，是因为如果程序服从该次序，就简单地把一切事件视为按先后顺序发生，其操作与这种次序保持一致.如果在一个线程内，某项操作先于另一项发生，那么其他线程所见的先后次序都必须如此

    - 宽松次序

            在单一线程内，同一个变量上的操作仍然服从先行关系，但几乎不要求线程间存在任何次序关系.该内存次序的唯一要求是，在一个线程内，对相同变量的访问次序不得重新编排。对于给定的线程，一旦它见到某原子变量在某时刻持有的值，则该线程的后续读操作不可能读取相对更早的值。memory_order_relaxed次序无须任何额外的同步操作，线程间仅存的共有信息是每个变量的改动序列

            要理解宽松次序如何工作，请将每个原子变量想象成一位记录员，各自身处小隔间里，手持笔记本，而笔记本上有一列数值。你可以致电记录员，请他报告当中的一个值，或请他记录一个新值。若是前者，他就报告列表中的一个值；若是后者，则他将新值记录在列表末尾。当你第一次向记录员询问数值时，他即从笔记本中任选一个值报告。如果再次询问，他可能重复报告同一个值，也可能报告它后方的某一个值（两值不一定相邻），但不会报告它前方的值。若你让记录员记录新值，过后再询问，他可能报告该新值，也可能报告该值后方的某一个值。设想起初列表是5、10、23、3、1和2。如果你开始询问，就会得到其中任意一个值。假定回答是10，那么下次再询问时，记录员可能又报告10，也可能报告10后面的值，但不可能报告5。以5次电话询问为例，他的回答可能是10、10、1、2、2。如果你请他记录42，他就将其记录在列表末尾。之后再向他询问，他只能反复报告42，除非他的列表上又出现了另一个新值[22]，而且他愿意告诉你那个新值.现在，设想Carl也有此记录员的电话，也与他通电话，或者询问，或者告知记录员记录新值，他们两人之间也遵守上述规则。记录员只有一部电话，所以每次只能应付一人，并且他的笔记本上的数值列表清晰、准确。然而，若你让他记录新值，他不一定会把这个新值告诉Carl，反之同理。如果Carl向记录员询问数值，答案是23；过后，你让他记录42；下一轮又换成Carl询问他，答案却不一定是42，记录员可能从23、3、1、2中任选一个告诉Carl。甚至有可能出现这种场景：Fred在你之后致电记录员，让他又记录67，然后Carl又连续多次询问，那记录员完全有可能依次回答23、3、3、1、67。而这串数值并未违反规则，与记录员向你提供的答案依然一致。记录员的行为就像是为每人准备一张标签，每次报告之后，就移动与询问者对应的标签，以标记刚刚回答过的数值

            现在进一步想象，记录员不止一位，整个楼层满是小隔间，众多记录员手持笔记本接听电话。他们就是拟人化的原子变量。每个原子变量都有自己的改动序列（笔记本上的数值列表），但各变量之间并不相关。而每位来电人士（你、Carl、Anne、Dave和Fred等）则是拟人化的线程，各项操作，并且全部遵循memory_order_relaxed内存序，这样便会形成上述场景。其实，你还能指挥小隔间里的记录员执行更多操作，例如，“告诉我列表最后的值，再记录一个新值”（交换操作）；又如，“若我给出的值与列表最后的值相等，就写下这个值；否则，请告诉我最后的值是什么”（compare_exchange_strong()函数）。但这些操作不会影响一般原则

            尽量避免使用

    - 获取-释放次序        

            获取-释放次序比宽松次序严格一些，它会产生一定程度的同步效果，而不会形成服从先后一致次序的全局总操作序列。在该内存模型中，原子化载入即为获取操作（memory_order_acquire[23]），原子化存储即为释放操作（memory_order_release），而原子化“读-改-写”操作（像fetch_add()和exchange()）则为获取或释放操作，或二者皆是（memory_order_acq_rel）。这种内存次序在成对的读写线程之间起到同步作用。释放与获取操作构成同步关系，前者写出的值由后者读取。换言之，若多个线程服从获取-释放次序，则其所见的操作序列可能各异，但其差异的程度和方式都受到一定条件的制约

            memory_order_consume次序相当特别：它完全针对数据依赖，引入了线程间先行关系中的数据依赖细节。其特别之处还在于，C++17标准明确建议我们对其不予采用

            数据依赖的概念相对直观：若我们执行两项操作，第一项得出的结果由第二项继续处理，即构成数据依赖。数据依赖需要处理两种关系：前序依赖（dependency-ordered- before）和携带依赖（carries-a-dependency-to）。与流程先后顺序关系类似，携带依赖关系属于严格的单一线程中的内部关系，它模拟了两项操作之间的数据依赖：如果甲操作的结果是乙操作的操作数，那么甲操作带给乙操作依赖；如果甲操作的结果值属于标量类型（如int），即便甲操作的结果存储到某个变量中，该变量后来又充当乙操作的操作数，这种关系仍然成立。这种关系同样可传递，如果甲操作带给乙操作依赖，且乙操作带给丙操作依赖，那么甲操作带给丙操作依赖

            std::kill_dependency()是一个简单的函数模板，它复制调用者给出的参数，直接将其作为返回值，借此打断依赖链.在实际代码中，凡是要用到memory_order_consume次序的情形，我们应当一律改用memory_order_acquire次序，而使用std::kill_dependency()是没有必要的

- 释放序列和同步关系



- 栅栏

        栅栏具备多种操作，用途是强制施加内存次序，却无须改动任何数据

        通常，它们与服从memory_order_relaxed次序的原子操作组合使用。栅栏操作全部通过全局函数执行。当线程运行至栅栏处时，它便对线程中其他原子操作的次序产生作用。栅栏也常常被称作“内存卡”或“内存屏障”，其得名原因是它们在代码中划出界线，限定某些操作不得通行

        栅栏的整体运作思路是：若存储操作处于释放栅栏后面，而存储操作的结果为获取操作所见，则该释放栅栏与获取操作同步；若载入操作处于获取栅栏前面，而载入操作见到了释放操作的结果，则该获取栅栏与释放操作同步

        栅栏只有放置在变量x和y的存储操作之间，才会强制这两个操作服从先后次序。就其他原子操作之间的先行关系而言，栅栏存在与否并不影响已经加诸其上的次序。

- 凭借原子操作令非原子操作服从内存次序

        利用栅栏

- 强制非原子操作服从内存次序

