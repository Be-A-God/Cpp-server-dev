# **面向对象**

- 面向对象和面向过程的区别

  - 面向过程：根据业务逻辑从上到下写代码
  - 面向对象：将数据与函数绑定到一起进行封装，这样能够快速地开发程序

- 面向对象三大特征

  - 封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互
  - 继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
  - 多态：用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。实现多态，有二种方式，重写，重载

- 继承方式

|    继承方式    |   私有继承   |   保护继承   |   公有继承   |
| :------------: | :----------: | :----------: | :----------: |
| 基类的私有成员 |    不可见    |    不可见    |    不可见    |
| 基类的保护成员 | 变为私有成员 | 仍为保护成员 | 仍为保护成员 |
| 基类的公有成员 | 变为私有成员 | 变为保护成员 | 仍为公有成员 |

---

# **类**

- 只定义折构函数的情况下

  - 编译器自动生成拷贝构造函数
  - 编译器自动生成默认构造函数
  - ~~需要定义自己的拷贝构造函数~~
  - ~~需要定义自己的默认构造函数~~

- 默认生成函数（空类情况下）

  - 无参的构造函数（默认构造函数）
  - 赋值运算符
  - 折构函数（非虚）
  - 拷贝构造函数

- 类对象初始化顺序

  - 基类构造函数 -> 成员类对象构造函数 -> 自身构造函数
  - 成员变量的初始化和声明顺序有关；构造函数的调用和类派生列表的顺序相关
  - 折构顺序和构造顺序相反

- 深拷贝与浅拷贝

  - 浅拷贝：源对象和目标对象共用一份实体（实际地址相同）
  - 深拷贝：先开辟空间再拷贝源对象内容到目标对象，不会重复释放同一块内存

- 可以定义引用数据成员的条件

  - 不能使用默认构造函数初始化
  - 构造函数的形参也必须是引用类型
  - 不能在构造函数里初始化，必须在初始化列表里进行初始化

- 常函数

  - 类的成员函数后加上 `const` 
  - 常函数不能修改对象的非静态数据成员
  - 只能调用 `const` 成员函数

- 仿函数

  - 又称为函数对象，是一个能够行使函数功能的类
  - 通过重载 `operate()` 运算符

- 虚继承

  - 多重继承：从不同途径继承来的同一基类，会在子类中存在多份拷贝（浪费空间+二义性）

  - 虚继承解决该问题

  - 菱形继承

    - A 中含有 间接基类 D 的两份数据成员，调用时会产生二义性

    - 虚继承中虚基类的初始化由最底层的派生类负责初始化（忽略直接派生类对虚基类的构造函数调用）

  - 虚基表指针：虚基类的直接派生类对象所存储的指向共有虚基类地址的指针

  - 虚基类表：记录了虚基类和派生类的偏移地址

- 类权限

|  关键字   |              权限              |
| :-------: | :----------------------------: |
|  public   |       可以被任意实体访问       |
| protected | 只允许子类及本类的成员函数访问 |
|  private  |    只允许本类的成员函数访问    |

---

# **纯虚函数**

- 能否实例化（不能）

  - 纯虚函数的虚函数表中对应的项被赋值为 0 ，指向一个不存在的函数
  - 本质上是一个接口

- 在子类中可以被重写实现多态

- 不能有 `static` 标识符： `static` 函数要求编译时绑定，虚函数是动态绑定

- 本质是一个没有实现的虚函数

---

# **虚函数**

- 虚函数表和类对应；虚表指针和对象对应

- 虚函数表是一个函数指针数组，在编译阶段生成；虚函数表存在 `.rodata` 段；编译阶段确定派生类和基类的虚函数在虚函数表的偏移量

- 虚函数保存在代码段

- 虚函数按照在基类中的声明顺序放在虚函数表中

- 必须是基类的非静态成员

- 不能声明为虚函数的函数

  - 普通函数（非成员函数）：编译时绑定函数
  - 静态成员函数：属于类而非某一个对象，没有 `this` 指针无法进行对象的判别
  - 内联成员函数：内联函数在编译时被展开，而虚函数是运行时动态绑定
  - 构造函数：虚函数的运行建立在对象的基础上，而此时对象尚未形成
  - 友元函数：不支持友元函数的继承，没有继承特性的函数没有虚函数的说法

- 虚函数表的内容什么时候写进去

  - 虚函数表是一个存储虚函数地址的数组，以空指针结尾
  - 虚函数表在编译阶段生成
  - 类对象内存开辟之后，写入对象中的虚表指针，顺序在调用构造函数（的函数体）之前

- 总结

  - 每一个基类都会有自己的虚函数表，派生类的虚函数表的数量根据继承的基类的数量来定
  - 派生类的虚函数表的顺序，和继承时的顺序相同
  - 派生类自己的虚函数放在第一个虚函数表的后面，顺序也是和定义时顺序相同
  - 对于派生类如果要覆盖父类中的虚函数，那么会在虚函数表中代替其位置
  - 虚表指针是对象的第一个数据成员

---

# **构造函数**

- 构造函数类别

  - 默认构造函数（有了有参的构造函数后不再提供）
  - 初始化构造函数
  - 拷贝构造函数
  - 移动构造函数

- 构造函数不能是虚函数

  - 存储空间：虚函数表的地址存储在对象的内存空间（虚表指针）；构造的时候对象还没有实例化，此时没有内存空间分配无法调用该虚函数（悖论）
  - 使用角度：虚函数是用于在信息不全的情况下，使函数得到正确的调用；但构造函数初始化实例对象是明确的，将其设为虚函数没有意义
  - 实现角度：虚函数表在构造函数之后才建立；构造函数在对象生命周期只执行一次，不是对象的动态行为，没有成为虚函数的必要

- 构造函数能不能调用虚方法

  - 语法上没问题但是没有意义
  - 派生类对象构造期间进入基类的构造函数，对象类型就变成了基类类型，而不是派生类型
  - 同理，进入基类折构函数时，对象也是基类类型

- 拷贝构造函数的传参方式

  - 必须使用引用传参
  - 值传参：在传值的时候会将实参拷贝一份临时数据，此时会调用拷贝构造函数...如此无限递归下去导致栈溢出
  - 传指针本质上也是值传递

---

# **模板**

- 模板类什么时候实现

  - 模板实例化

    - 显式实例化：明确告诉模板使用什么类型去生成具体的类或函数
    - 隐式实例化：编译过程中由编译器决定实例化的类型

  - 模板具体化：指定模板形参类型

- 类模板和模板类的区别

  - 类模板是模板的定义，不是实实在在的类
  - 模板类是实实在在的类定义，是类模板的实例化
