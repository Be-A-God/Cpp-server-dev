# **C++语言的特点**

- 三大特性：封装、继承、多态
- 可复用性高，引入模板和标准模板库 STL
- 代码质量高、运行效率高

---

# **`struct` 和 `class` 的区别**

- `struct` 描述一个数据结构的集合； `class` 是对一个对象数据的封装
- `struct` 的默认访问权限是 `public` ； `class` 的默认访问权限是 `private` 
- 继承关系中， `struct` 默认是公有继承； `class` 是私有继承
- `class` 能够用于定义模板参数，而 `struct` 不能

---

# **`include` 中头文件的顺序以及双引号和尖括号的区别**

- 区别

  - 尖括号<>的头文件是系统文件，双引号""的头文件是自定义文件
  - 编译器预处理阶段查找头文件的路径不一样

- 查找路径

  - 使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量
  - 使用双引号""的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量

---

# **C++从代码到可执行二进制文件的过程**

- 四个过程：预编译、编译、汇编、链接

- 预编译

  - 将所有的#define删除，并且展开所有的宏定义
  - 处理所有的条件预编译指令，如#if、#ifdef
  - 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置
  - 过滤所有的注释
  -  添加行号和文件名标识

- 编译

  - 词法分析：将源代码的字符序列分割成一系列的记号
  - 语法分析：对记号进行语法分析，产生语法树
  - 语义分析：判断表达式是否有意义
  - 代码优化
  - 目标代码生成：生成汇编代码
  - 目标代码优化

- 汇编：这个过程主要是将汇编代码转变成机器可以执行的指令

- 链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序

  - 静态链接

    - 在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中
    - Windows下以 `.lib` 为后缀，Linux下以 `.a` 为后缀

  - 动态链接

    - 在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息
    - Windows下以 `.dll` 为后缀，Linux下以 `.so` 为后缀

---

# **`static` 关键字的作用**

- 定义全局静态变量和局部静态变量

  - 初始化的静态变量会在数据段（ `.data` ）分配内存
  - 未初始化的静态变量在BSS段（ `.bss` ）分配内存（ `.bss` 段会被清零）
  - 静态变量只能在本源文件中使用
  - 未初始化的局部静态变量会被自动初始化为0

- 定义静态函数：只能在本源文件中使用

- 定义类的静态成员变量：所有对象共享同一个静态成员变量

- 定义类的静态成员函数：同上；静态成员函数没有 `this` 指针，只能访问静态成员变量

---

# **指针**

- 32位平台下，对指针进行 `sizeof` 运算结果都是4；64位平台下，对指针进行 `sizeof` 结果运算都是8
- 指针本身是变量，其本身所存放的也是变量，所以指针的存储空间不能确定
- 回调：从别人的库里面调用我们自己的函数
- 野指针：指针指向的位置不可知（没有初始化）
- 悬浮指针：指针指向的内存已被释放

---

# **静态变量初始化的时间**

- 全局或静态对象当且仅当对象首次使用时才进行构造
- C++的作用域：全局、局部、类、语句、文件作用域、命名空间
- 静态变量都存储在静态存储区，程序结束时才回收（类静态变量是当超出类作用域时）

---

# **`nullptr` 调用成员函数**

- 编译时对象就绑定函数地址，和指针的值无关
- 此时 `this = nullptr` ，解引用时会运行出错

---

# **`new` 和 `malloc` 的区别**

- `new` 是操作符， `malloc` 是函数
- `new` 先分配内存，再调用构造函数创建对象，返回指向该对象的指针
- `malloc` 采用内存池管理方式分配内存，返回 `void *` 空类型指针
- `new` 失败抛出异常， `malloc` 失败返回空指针

---

# **`const` 和 `define` 的区别**

- `const` 生效于编译期； `define` 生效于预编译阶段
- `const` 定义常量占用内存； `define` 定义的常量是直接操作数，不占用内存
- `const` 是带类型的； `define` 是不带类型的


