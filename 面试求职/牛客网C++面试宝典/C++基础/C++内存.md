# **内存分配**

- 堆和栈的区别

  - 栈由操作系统自动分配释放；堆由程序员分配释放
  - 栈采用一级缓存；堆采用二级缓存，速度慢些
  - 栈先进后出；堆类似数组结构

- 内存区

  - 栈：函数内局部变量
  - 堆：由 `new` 分配的内存块
  - 自由存储区：由 `malloc` 分配的内存块
  - 全局/静态存储区：全局变量和静态变量分配的内存
  - 常量存储区：存放常量的存储区

- 内存泄漏

  - `new` 和 `malloc` 后没有进行 `delete` 和 `free` 
  - 派生类继承基类，基类折构函数不是虚函数
  - `Windows` 句柄资源使用后没有释放

---

# **一个程序的 `section`**

- 从低地址到高地址：代码段、数据段、BSS段、堆、共享区、栈

  - 代码段：存放程序执行代码的一块内存区域
  - 数据段：存放程序中已初始化的全局变量和静态变量的一块内存区域
  - BSS段：存放程序中未初始化的全局变量和静态变量的一块内存区域
  - 堆：动态申请内存用。堆从低地址向高地址增长
  - 共享区：位于堆和栈之间
  - 栈：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间

- BSS段

  - 用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域
  - 可读写
  - 程序执行之前BSS段会自动清零

![20220317235438](https://raw.githubusercontent.com/Be-A-God/Drawing-bed/main/note/20220317235438.png)

---

# **`atomoic` 内存顺序**

- `memory_order_relaxed` ：在原子类型上的操作以自由序列执行，没有任何同步关系，仅对此操作要求原子性
- `memory_order_consume` ：只会对其标识的对象保证该对象存储先行于那些需要加载该对象的操作
- `memory_order_acquire` ：当前线程的读写操作都不能重排到此操作之前
- `memory_order_release` ：当前线程的读写操作都不能重排到此操作之后
- `memory_order_acq_rel` ：在此内存顺序的读-改-写操作既是获得加载又是释放操作。没有操作能够从此操作之后被重排到此操作之前，也没有操作能够从此操作之前被重排到此操作之后
- `memory_order_seq_cst` ：不仅是一个"获取释放"内存顺序，它还会对所有拥有此标签的内存操作建立一个单独全序
- 默认为 `memory_order_seq_cst`

---

# **内存对齐**

- 应用于三种数据类型 `struct` `class` `union` 

- 对齐原则

  - 数据成员对齐规则：结构 `struct` 或联合 `union` 的数据成员，第一个数据成员放在 `offset` 为 0 的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始

  - 结构体作为成员：如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储

  - 收尾工作：结构体的总大小，也就是 `sizeof` 的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍（基本类型不包括 `struct` `class` `uinon` ）

  - `sizeof(union)` 以结构里面 size 最大元素为 union 的 size ，因为在某一时刻， union 只有一个成员真正存储于该地址